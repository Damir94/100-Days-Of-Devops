# 100 Days of Devops - Day 55: Web Server Pod with Sidecar Log Shipping

## Overview
This project demonstrates how to deploy a web server (Nginx) and a log shipping sidecar container 
within the same Kubernetes Pod, following the Sidecar pattern and the Separation of Concerns principle.

The goal is to:
 - Run a web server container using the nginx:latest image.
 - Run a second container that ships or displays the Nginx logs.
 - Use a shared emptyDir volume so both containers can access the same log files.
 - Avoid persistent storage since logs are only needed for the last 24 hours.

## Design Concept
#### Separation of Concerns
 - Nginx container focuses only on serving web traffic.
 - Sidecar container is dedicated to log shipping and monitoring.
This approach improves maintainability and keeps each container’s purpose clear and isolated.

#### Sidecar Pattern
Both containers share a temporary directory (emptyDir volume).
Nginx writes its logs to /var/log/nginx, and the sidecar container reads and processes them.

## Implementation Steps
1. Create a Pod
A single Pod named webserver is created containing:
 - nginx-container → serves web pages.
 - sidecar-container → reads and ships logs.

2. Define Shared Volume
An emptyDir volume called shared-logs is mounted at /var/log/nginx in both containers.
This ensures both containers have access to the same log directory.

3. Configure the Containers
Nginx Container
 - Image: nginx:latest
 - Name: nginx-container
 - Role: Serves web traffic and generates access and error logs in /var/log/nginx.

#### Sidecar Container
 - Image: ubuntu:latest
 - Name: sidecar-container
Command:
```bash
sh -c "while true; do cat /var/log/nginx/access.log /var/log/nginx/error.log; sleep 30; done"
```
Role: Continuously outputs Nginx logs every 30 seconds for aggregation or viewing.

#### Pod Manifest
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: webserver
spec:
  volumes:
    - name: shared-logs
      emptyDir: {}

  containers:
    - name: nginx-container
      image: nginx:latest
      volumeMounts:
        - name: shared-logs
          mountPath: /var/log/nginx

    - name: sidecar-container
      image: ubuntu:latest
      command: ["sh", "-c", "while true; do cat /var/log/nginx/access.log /var/log/nginx/error.log; sleep 30; done"]
      volumeMounts:
        - name: shared-logs
          mountPath: /var/log/nginx
```
#### Deployment
Apply the Pod:
```bash
kubectl apply -f webserver.yaml
```
Verify Pod Status:
```bash
kubectl get pods
```
Check Logs from Sidecar:
```bash
kubectl logs -f webserver -c sidecar-container
```

<img width="1549" height="888" alt="Screenshot 2025-10-18 at 9 35 35 AM" src="https://github.com/user-attachments/assets/e044e251-a5d1-4c6c-a1f0-a2d674de7a99" />

You’ll see continuous output from both access and error logs generated by Nginx.

## Key Takeaways
 - Sidecar pattern allows log processing or monitoring without altering the web server container.
 - emptyDir volume provides shared, temporary storage within the Pod lifecycle.
 - Stateless logging is efficient when historical persistence isn’t required.

## Future Enhancements
 - Integrate a real log shipping tool (e.g., Fluent Bit, Filebeat, or Promtail) inside the sidecar.
 - Forward logs to a centralized system like Elasticsearch, Grafana Loki, or CloudWatch Logs.

## Conclusion
This implementation demonstrates how to apply the Sidecar pattern effectively in Kubernetes for log management.
By separating concerns between Nginx and the log shipping container, the system remains modular, maintainable, and production-ready.
